#include "crypto_api_rsa.h"
#include "common.h"
#include <Windows.h>
#include <Wincrypt.h>
#include <stdio.h>
#define MY_ENCODING_TYPE  (PKCS_7_ASN_ENCODING | X509_ASN_ENCODING)

#define RSA2048BIT_KEY 0x8000000


DWORD rsa_Encrypt(LPBYTE PublicKey, DWORD SizeKey, LPBYTE InData, DWORD SizeInData, LPBYTE *OutData)
{
    HCRYPTPROV CryptProv = NULL; // Initialize variables
    HCRYPTKEY CryptKey = NULL;
    DWORD SizeData = SizeInData;
    DWORD SizeBuffer = 0;
    DWORD Result = -1;

    do {
        if (!OpenCryptContext(&CryptProv)) {
            xstrerror("CryptAcquireContext()");
            break;
        }

        if (!CryptImportKey(CryptProv, PublicKey, SizeKey, 0, 0, &CryptKey)) // Import key
            break;

        if (!CryptEncrypt(CryptKey, NULL, TRUE, 0, NULL, &SizeData, 0)) // Retrieve length of encrypted data
            break;

        SizeBuffer = SizeData;
        SizeData = SizeInData;

        if (SizeBuffer < SizeInData) // if SizeEncryptedData is smaller than SizeInData and encryption is happening, an error has occured.
            break;

        *OutData = (LPBYTE)xmalloc(SizeBuffer);

        if (*OutData == NULL)
            break;

        //RtlSecureZeroMemory(OutData, SizeData); // Clear memory
        memcpy(*OutData, InData, SizeInData); // Put InData temporarily into OutData for encryption

        if (CryptEncrypt(CryptKey, NULL, TRUE, 0, *OutData, &SizeData, SizeBuffer)) // Encrypt
            Result = SizeData; // Set return value to the encrypted data size
    } while (false);

    if (CryptKey != NULL) // Clean up
        CryptDestroyKey(CryptKey);

    if (CryptProv != NULL)
        CryptReleaseContext(CryptProv, 0);

    if (OutData != NULL && !Result)
        xfree(*OutData);

    return Result;
}


DWORD rsa_Decrypt(LPBYTE PrivateKey, DWORD SizeKey, LPBYTE Data, LPDWORD SizeData)
{
    HCRYPTPROV CryptProv = NULL; // Initialize variables
    HCRYPTKEY CryptKey = NULL;
    DWORD Result = -1;

    do {
        if (!OpenCryptContext(&CryptProv)) {
            xstrerror("CryptAcquireContext()");
            break;
        }

        if (!CryptImportKey(CryptProv, PrivateKey, SizeKey, 0, 0, &CryptKey)) // Import key
            break;

        if (!CryptDecrypt(CryptKey, NULL, TRUE, 0, Data, SizeData)) // Decrypt data and retrieve decrypted size
            break;

        Result = *SizeData; // Set return value to the decrypted data size
    } while (false);

    if (CryptKey != NULL) // Clean up
        CryptDestroyKey(CryptKey);

    if (CryptProv != NULL)
        CryptReleaseContext(CryptProv, 0);

    return Result;
}


void rsa_encrypt_test()
{
    BYTE rsa_public_key[] = {
        0x06, 0x02, 0x00, 0x00, 0x00, 0xa4, 0x00, 0x00,
        0x52, 0x53, 0x41, 0x31, 0x00, 0x08, 0x00, 0x00,
        0x01, 0x00, 0x01, 0x00, 0x77, 0xe5, 0xeb, 0x1f,
        0xae, 0xd8, 0xad, 0xd4, 0xe9, 0x28, 0xbf, 0x53,
        0x38, 0xd4, 0xd3, 0xcf, 0xf2, 0xa0, 0x50, 0x41,
        0xd6, 0x03, 0xe2, 0x23, 0x2c, 0x82, 0x38, 0x1a,
        0x5d, 0x5d, 0x0d, 0x6f, 0xa4, 0xc7, 0x67, 0x7b,
        0x5e, 0xa3, 0x26, 0x6e, 0x78, 0x35, 0xef, 0xca,
        0x19, 0x1c, 0xb8, 0xac, 0x0b, 0xe4, 0x79, 0xc9,
        0x4d, 0x7b, 0xd2, 0xea, 0x99, 0xcc, 0x4b, 0x60,
        0xff, 0xfc, 0x2f, 0x9c, 0x07, 0xad, 0x27, 0x84,
        0x4c, 0x64, 0x0e, 0x86, 0x9a, 0x8f, 0xb3, 0x34,
        0x35, 0x64, 0x13, 0x55, 0x6a, 0x84, 0x44, 0xb2,
        0x6d, 0x62, 0x28, 0xd3, 0xfe, 0xc3, 0x0f, 0x67,
        0x09, 0x25, 0xb5, 0x2c, 0x66, 0x80, 0x07, 0x3b,
        0xb5, 0xda, 0x0f, 0x55, 0xda, 0xee, 0xa0, 0x4f,
        0x6d, 0x60, 0x02, 0xb1, 0x34, 0x0d, 0xbd, 0xeb,
        0x07, 0xcd, 0x86, 0x8c, 0x36, 0xca, 0x98, 0x21,
        0x9c, 0x68, 0x48, 0x60, 0xb5, 0xe2, 0x80, 0x9c,
        0xe8, 0xc1, 0xdd, 0xb0, 0x74, 0xd9, 0x1e, 0xea,
        0x3b, 0x52, 0x21, 0x6a, 0xb1, 0x5b, 0xbb, 0xf3,
        0xd5, 0x80, 0xce, 0x33, 0x6f, 0x3d, 0xe2, 0x36,
        0xd8, 0x15, 0x9a, 0x33, 0xa9, 0x14, 0x69, 0xac,
        0xe7, 0xa2, 0x3d, 0xbf, 0xd0, 0x13, 0x8c, 0x75,
        0x12, 0x73, 0xc8, 0xe8, 0x9d, 0xe0, 0xda, 0x51,
        0xad, 0x88, 0x08, 0x33, 0xe3, 0x7a, 0x92, 0x5a,
        0x2c, 0x6a, 0x15, 0xef, 0xa9, 0xb1, 0x0d, 0xcf,
        0x1f, 0x03, 0x88, 0xfe, 0x0d, 0x92, 0xb1, 0x2c,
        0x16, 0x11, 0x12, 0xc9, 0xda, 0xe4, 0x61, 0x0f,
        0x87, 0x4d, 0x7b, 0x04, 0x4e, 0x31, 0x70, 0xd1,
        0x79, 0x63, 0x70, 0x23, 0x95, 0x13, 0x01, 0xc9,
        0xfa, 0x7c, 0x02, 0xb6, 0xd3, 0xaf, 0x59, 0xa2,
        0x3f, 0xe4, 0xaf, 0xbd, 0x46, 0x13, 0x2d, 0x12,
        0xdb, 0x47, 0x27, 0x1b, 0x9e, 0x2d, 0x50, 0x93,
        0x36, 0x5f, 0xba, 0xa1
    };
    char inData[] = "hello world!";
    LPBYTE OutData = NULL;
    DWORD OutData_Len = rsa_Encrypt(rsa_public_key, sizeof(rsa_public_key), (LPBYTE)inData, strlen(inData), &OutData);
    printf("rsa encrypt data:\n");
    print_bin2c(OutData, OutData_Len);
    printf("\n\n");
    BYTE rsa_private_key[] = {
        0x07, 0x02, 0x00, 0x00, 0x00, 0xa4, 0x00, 0x00,
        0x52, 0x53, 0x41, 0x32, 0x00, 0x08, 0x00, 0x00,
        0x01, 0x00, 0x01, 0x00, 0x77, 0xe5, 0xeb, 0x1f,
        0xae, 0xd8, 0xad, 0xd4, 0xe9, 0x28, 0xbf, 0x53,
        0x38, 0xd4, 0xd3, 0xcf, 0xf2, 0xa0, 0x50, 0x41,
        0xd6, 0x03, 0xe2, 0x23, 0x2c, 0x82, 0x38, 0x1a,
        0x5d, 0x5d, 0x0d, 0x6f, 0xa4, 0xc7, 0x67, 0x7b,
        0x5e, 0xa3, 0x26, 0x6e, 0x78, 0x35, 0xef, 0xca,
        0x19, 0x1c, 0xb8, 0xac, 0x0b, 0xe4, 0x79, 0xc9,
        0x4d, 0x7b, 0xd2, 0xea, 0x99, 0xcc, 0x4b, 0x60,
        0xff, 0xfc, 0x2f, 0x9c, 0x07, 0xad, 0x27, 0x84,
        0x4c, 0x64, 0x0e, 0x86, 0x9a, 0x8f, 0xb3, 0x34,
        0x35, 0x64, 0x13, 0x55, 0x6a, 0x84, 0x44, 0xb2,
        0x6d, 0x62, 0x28, 0xd3, 0xfe, 0xc3, 0x0f, 0x67,
        0x09, 0x25, 0xb5, 0x2c, 0x66, 0x80, 0x07, 0x3b,
        0xb5, 0xda, 0x0f, 0x55, 0xda, 0xee, 0xa0, 0x4f,
        0x6d, 0x60, 0x02, 0xb1, 0x34, 0x0d, 0xbd, 0xeb,
        0x07, 0xcd, 0x86, 0x8c, 0x36, 0xca, 0x98, 0x21,
        0x9c, 0x68, 0x48, 0x60, 0xb5, 0xe2, 0x80, 0x9c,
        0xe8, 0xc1, 0xdd, 0xb0, 0x74, 0xd9, 0x1e, 0xea,
        0x3b, 0x52, 0x21, 0x6a, 0xb1, 0x5b, 0xbb, 0xf3,
        0xd5, 0x80, 0xce, 0x33, 0x6f, 0x3d, 0xe2, 0x36,
        0xd8, 0x15, 0x9a, 0x33, 0xa9, 0x14, 0x69, 0xac,
        0xe7, 0xa2, 0x3d, 0xbf, 0xd0, 0x13, 0x8c, 0x75,
        0x12, 0x73, 0xc8, 0xe8, 0x9d, 0xe0, 0xda, 0x51,
        0xad, 0x88, 0x08, 0x33, 0xe3, 0x7a, 0x92, 0x5a,
        0x2c, 0x6a, 0x15, 0xef, 0xa9, 0xb1, 0x0d, 0xcf,
        0x1f, 0x03, 0x88, 0xfe, 0x0d, 0x92, 0xb1, 0x2c,
        0x16, 0x11, 0x12, 0xc9, 0xda, 0xe4, 0x61, 0x0f,
        0x87, 0x4d, 0x7b, 0x04, 0x4e, 0x31, 0x70, 0xd1,
        0x79, 0x63, 0x70, 0x23, 0x95, 0x13, 0x01, 0xc9,
        0xfa, 0x7c, 0x02, 0xb6, 0xd3, 0xaf, 0x59, 0xa2,
        0x3f, 0xe4, 0xaf, 0xbd, 0x46, 0x13, 0x2d, 0x12,
        0xdb, 0x47, 0x27, 0x1b, 0x9e, 0x2d, 0x50, 0x93,
        0x36, 0x5f, 0xba, 0xa1, 0x49, 0x0f, 0x6f, 0xd4,
        0x58, 0x44, 0x1a, 0x4e, 0x34, 0x94, 0xaa, 0xe0,
        0x70, 0xcd, 0x93, 0xe7, 0x74, 0xf1, 0x11, 0xe7,
        0x55, 0xae, 0x37, 0xf4, 0x33, 0x6c, 0x6b, 0xe0,
        0x0e, 0x5a, 0xb1, 0x92, 0x8b, 0x4e, 0xe1, 0xc4,
        0xbf, 0x88, 0x97, 0xab, 0xce, 0xd9, 0x82, 0x12,
        0x71, 0x2b, 0xcc, 0x77, 0x17, 0x7c, 0x8c, 0x9e,
        0x1e, 0xad, 0xa8, 0x5c, 0x5c, 0x3a, 0x59, 0xdc,
        0xf2, 0xee, 0x49, 0xe6, 0x8f, 0xd0, 0xc1, 0x18,
        0xaf, 0x9d, 0xad, 0xf3, 0x0b, 0x7d, 0xe9, 0x01,
        0x94, 0x38, 0xa9, 0x1f, 0xfa, 0x24, 0xca, 0xc0,
        0xad, 0x7b, 0xab, 0xa5, 0xa2, 0xa7, 0xe3, 0xe3,
        0x96, 0x1e, 0x93, 0xb2, 0x17, 0xa8, 0xe2, 0xb0,
        0x67, 0x30, 0x3b, 0x6a, 0xef, 0x2d, 0xd0, 0x27,
        0x56, 0xf5, 0x61, 0x4c, 0x77, 0xf1, 0x94, 0x3e,
        0xa0, 0xbe, 0xd3, 0x77, 0xfa, 0xc4, 0x03, 0xef,
        0xb8, 0xbc, 0x99, 0xd5, 0xbf, 0x8e, 0xed, 0xe0,
        0x59, 0x0c, 0xea, 0x4d, 0x8e, 0xec, 0x4b, 0x18,
        0xf3, 0xbf, 0xa7, 0x13, 0xbd, 0x72, 0xba, 0x3d,
        0x97, 0x11, 0xfe, 0x11, 0xf8, 0xd3, 0xc9, 0xeb,
        0xa9, 0x9b, 0x13, 0x91, 0xbc, 0x6e, 0x89, 0x12,
        0x35, 0xf2, 0xd1, 0x76, 0x98, 0xba, 0xce, 0xc4,
        0xb0, 0xc3, 0x65, 0x88, 0xb8, 0x3b, 0x56, 0x57,
        0xb3, 0xa7, 0x0e, 0x37, 0x33, 0xb1, 0x55, 0x00,
        0xb5, 0xab, 0x03, 0x51, 0x9b, 0xbb, 0x6e, 0x80,
        0x4a, 0x22, 0x3e, 0xed, 0x40, 0x5c, 0x4f, 0x96,
        0x81, 0x9e, 0xb6, 0x92, 0xa8, 0x9d, 0xa0, 0x7a,
        0xd4, 0xd3, 0xa1, 0x15, 0xa4, 0xcf, 0x96, 0x4a,
        0x22, 0x7c, 0xae, 0xbd, 0x19, 0x5b, 0x0b, 0xea,
        0x18, 0x04, 0xf1, 0x52, 0xe1, 0xbd, 0x62, 0x6b,
        0x95, 0xed, 0xe5, 0x1f, 0x30, 0x59, 0x7b, 0x38,
        0x03, 0x5b, 0x96, 0x6b, 0x6c, 0xba, 0x84, 0x20,
        0x1f, 0xb2, 0xd4, 0xc1, 0x81, 0x61, 0x6e, 0xb2,
        0x6d, 0x1c, 0xa6, 0xbd, 0x9d, 0x68, 0x64, 0x07,
        0xde, 0xaa, 0xe5, 0x2e, 0xc0, 0x37, 0x2d, 0xd9,
        0x09, 0x24, 0x1a, 0xcf, 0xda, 0xc1, 0x5b, 0xb5,
        0x77, 0xb1, 0x91, 0xb9, 0xc4, 0xfc, 0x89, 0x2c,
        0x72, 0xc9, 0xc8, 0xb2, 0x84, 0x7b, 0x7d, 0xe9,
        0x95, 0x74, 0xf6, 0xc1, 0x3f, 0x0e, 0x6b, 0xdf,
        0xca, 0x52, 0xbf, 0xe9, 0x77, 0xdb, 0x8d, 0x8b,
        0x0e, 0xa7, 0xc6, 0xff, 0x20, 0x1d, 0x00, 0x55,
        0x2e, 0x1d, 0x23, 0x1b, 0x31, 0xaa, 0xa3, 0x5f,
        0x90, 0x36, 0x09, 0x37, 0x58, 0xd4, 0x4b, 0x17,
        0x58, 0xa9, 0x89, 0x6d, 0x1c, 0xf1, 0xb0, 0x16,
        0x75, 0x4e, 0xdb, 0xf1, 0x49, 0x2c, 0xef, 0x8e,
        0xcf, 0x05, 0x3a, 0xe2, 0x44, 0xcf, 0x9e, 0x5a,
        0xf1, 0x81, 0xe7, 0xf6, 0x03, 0x01, 0xfa, 0xed,
        0xdb, 0xae, 0x64, 0x53, 0xe3, 0xcc, 0xde, 0x67,
        0x4a, 0xaf, 0xa2, 0x32, 0x07, 0x18, 0x6e, 0xb8,
        0xe8, 0x8d, 0xc4, 0x0a, 0x6e, 0x23, 0xcf, 0x4f,
        0xec, 0x3e, 0x98, 0xa4, 0x22, 0x68, 0xd6, 0x67,
        0xd6, 0x28, 0x0e, 0x8e, 0x09, 0xf8, 0xbe, 0x95,
        0xea, 0xc2, 0x8d, 0xf0, 0xce, 0x2c, 0x15, 0x35,
        0x2f, 0xd9, 0x12, 0x5f, 0x67, 0x3e, 0xb9, 0x45,
        0x27, 0x13, 0xec, 0x79, 0xc9, 0xcc, 0xe0, 0xc6,
        0x29, 0xd4, 0x5c, 0x7f, 0xae, 0xb0, 0x1c, 0x45,
        0x75, 0x5b, 0x5b, 0x09, 0xfe, 0x22, 0x37, 0xfb,
        0x01, 0xc2, 0xe9, 0x8a, 0x7a, 0x38, 0xe1, 0x3f,
        0x7e, 0x94, 0x60, 0xfe, 0x43, 0xce, 0xcf, 0x42,
        0x0f, 0xa3, 0x0f, 0x62, 0xf4, 0x56, 0xb6, 0x06,
        0x1c, 0x6b, 0x61, 0x97, 0x68, 0x49, 0x28, 0x73,
        0xae, 0x8a, 0x3d, 0xf4, 0x5b, 0x16, 0xa3, 0x92,
        0x72, 0x31, 0xb5, 0xcc, 0xdd, 0x7f, 0x94, 0x61,
        0x5f, 0x38, 0x1b, 0x34, 0xc6, 0xcc, 0x4e, 0x39,
        0x2d, 0xd9, 0x1f, 0xb7, 0xe4, 0x37, 0xa9, 0x6a,
        0x07, 0xfd, 0x20, 0x3e, 0xf0, 0xaf, 0x28, 0x81,
        0xf0, 0xf5, 0x36, 0xa4, 0xa3, 0x84, 0x28, 0x25,
        0x0a, 0xe4, 0x5f, 0x8c, 0xc4, 0xe9, 0x1d, 0xff,
        0x50, 0x60, 0xaf, 0x4f, 0xaa, 0xa6, 0x77, 0x00,
        0x27, 0x90, 0x09, 0x6f, 0x2f, 0x44, 0xec, 0x57,
        0x69, 0xdc, 0x8a, 0xb7, 0x05, 0xda, 0xe1, 0xf9,
        0x08, 0x5f, 0x33, 0xcc, 0x77, 0xaf, 0xca, 0xc3,
        0x6c, 0x78, 0x1a, 0x00, 0x7f, 0x4d, 0x99, 0x44,
        0x32, 0x5d, 0xf6, 0x88, 0x12, 0x1f, 0x47, 0x0c,
        0x45, 0x17, 0x2d, 0xc0, 0x8f, 0x7d, 0xbf, 0x4b,
        0x31, 0x24, 0x5a, 0x0d, 0x40, 0xda, 0xb9, 0x22,
        0x61, 0x2d, 0x63, 0x9b, 0x18, 0x11, 0x51, 0x60,
        0x67, 0x7c, 0x63, 0x68, 0xc2, 0x11, 0x3a, 0x99,
        0x14, 0x00, 0xcd, 0x05, 0xcc, 0x23, 0x8f, 0x5b,
        0xcc, 0x98, 0xfb, 0x68, 0xed, 0x01, 0x72, 0xcd,
        0xb7, 0x46, 0xc3, 0x48, 0xa1, 0xa6, 0xc8, 0x83,
        0xca, 0x00, 0x69, 0x13, 0x68, 0x97, 0xd8, 0x94,
        0xe2, 0x54, 0x06, 0x62, 0x88, 0xb1, 0xef, 0xc7,
        0x10, 0xf8, 0x62, 0xc0, 0xf2, 0x8f, 0xe3, 0xfd,
        0xd9, 0x0c, 0xfa, 0x68, 0xad, 0x0e, 0xa4, 0xda,
        0x26, 0x84, 0x0e, 0x00, 0xc8, 0xac, 0x4d, 0x2c,
        0xb3, 0x94, 0x42, 0x8d, 0x73, 0xb2, 0x2c, 0x75,
        0xbe, 0xc5, 0xa2, 0xdb, 0x12, 0x4d, 0xf5, 0xcf,
        0xee, 0x04, 0x7b, 0xe5, 0xe9, 0x0c, 0x4d, 0x49,
        0xb2, 0x2b, 0xdb, 0xa1, 0xf2, 0x39, 0x4b, 0xdb,
        0xea, 0xf0, 0x04, 0xd6, 0x09, 0x3a, 0xbb, 0x99,
        0x43, 0xf8, 0xc1, 0x32, 0x0a, 0xfa, 0x88, 0x25,
        0x9b, 0x8e, 0x6b, 0x3a, 0xd4, 0x47, 0x6c, 0x31,
        0xaf, 0xa2, 0x0a, 0xc9, 0xbb, 0xcf, 0x89, 0x2a,
        0x63, 0x97, 0x0e, 0xbf, 0x29, 0x30, 0xca, 0x44,
        0x19, 0xba, 0x43, 0xcd, 0xea, 0x04, 0x63, 0x88,
        0x58, 0x52, 0x9a, 0x35, 0x0f, 0x1a, 0x0f, 0xe2,
        0x3d, 0xff, 0x23, 0x86, 0xea, 0xfb, 0xcd, 0xc1,
        0xe7, 0xaa, 0x41, 0x6f, 0xc5, 0xbd, 0x21, 0x73,
        0x57, 0xce, 0x8e, 0xae, 0x3c, 0xde, 0xc8, 0xb2,
        0x4b, 0x41, 0x41, 0x93, 0x9e, 0x1c, 0x3c, 0xc5,
        0xfd, 0x9e, 0x1c, 0x7c, 0xb3, 0x94, 0xf9, 0x7f,
        0x5e, 0x04, 0x21, 0xb4, 0x6e, 0x9d, 0x3d, 0xa2,
        0xa5, 0xdf, 0x81, 0xb1, 0x64, 0x1b, 0xbb, 0x26,
        0x08, 0x90, 0xd8, 0xca, 0x6a, 0x8e, 0xb7, 0xeb,
        0xe1, 0xeb, 0xc2, 0x26, 0x9a, 0x10, 0x42, 0x68,
        0x09, 0x9b, 0xa1, 0x1e, 0x9a, 0xaf, 0x7a, 0x97,
        0x8e, 0xd1, 0xc6, 0xc9, 0xf4, 0x21, 0xdf, 0x87,
        0xef, 0xb5, 0x38, 0xa7, 0x52, 0xb4, 0xef, 0x89,
        0x09, 0x81, 0x04, 0x60, 0xa4, 0x47, 0x81, 0x5e,
        0x50, 0xc5, 0xc1, 0x3a, 0xd8, 0xac, 0xe6, 0x14,
        0x03, 0x36, 0x06, 0x49, 0xe5, 0xbd, 0xa4, 0x8a,
        0x64, 0x48, 0xa0, 0x17
    };
    DWORD Decrypt_Len = rsa_Decrypt(rsa_private_key, sizeof(rsa_private_key), OutData, &OutData_Len);
    OutData[Decrypt_Len] = '\0';
    printf("rsa decrypt data:\n");
    printf("%s", OutData);
    printf("\n\n");
}

void rsa_encrypt_test2()
{
    BYTE rsa_public_key[] = {
        0x06, 0x02, 0x00, 0x00, 0x00, 0xa4, 0x00, 0x00,
        0x52, 0x53, 0x41, 0x31, 0x00, 0x08, 0x00, 0x00,
        0x01, 0x00, 0x01, 0x00, 0x77, 0xe5, 0xeb, 0x1f,
        0xae, 0xd8, 0xad, 0xd4, 0xe9, 0x28, 0xbf, 0x53,
        0x38, 0xd4, 0xd3, 0xcf, 0xf2, 0xa0, 0x50, 0x41,
        0xd6, 0x03, 0xe2, 0x23, 0x2c, 0x82, 0x38, 0x1a,
        0x5d, 0x5d, 0x0d, 0x6f, 0xa4, 0xc7, 0x67, 0x7b,
        0x5e, 0xa3, 0x26, 0x6e, 0x78, 0x35, 0xef, 0xca,
        0x19, 0x1c, 0xb8, 0xac, 0x0b, 0xe4, 0x79, 0xc9,
        0x4d, 0x7b, 0xd2, 0xea, 0x99, 0xcc, 0x4b, 0x60,
        0xff, 0xfc, 0x2f, 0x9c, 0x07, 0xad, 0x27, 0x84,
        0x4c, 0x64, 0x0e, 0x86, 0x9a, 0x8f, 0xb3, 0x34,
        0x35, 0x64, 0x13, 0x55, 0x6a, 0x84, 0x44, 0xb2,
        0x6d, 0x62, 0x28, 0xd3, 0xfe, 0xc3, 0x0f, 0x67,
        0x09, 0x25, 0xb5, 0x2c, 0x66, 0x80, 0x07, 0x3b,
        0xb5, 0xda, 0x0f, 0x55, 0xda, 0xee, 0xa0, 0x4f,
        0x6d, 0x60, 0x02, 0xb1, 0x34, 0x0d, 0xbd, 0xeb,
        0x07, 0xcd, 0x86, 0x8c, 0x36, 0xca, 0x98, 0x21,
        0x9c, 0x68, 0x48, 0x60, 0xb5, 0xe2, 0x80, 0x9c,
        0xe8, 0xc1, 0xdd, 0xb0, 0x74, 0xd9, 0x1e, 0xea,
        0x3b, 0x52, 0x21, 0x6a, 0xb1, 0x5b, 0xbb, 0xf3,
        0xd5, 0x80, 0xce, 0x33, 0x6f, 0x3d, 0xe2, 0x36,
        0xd8, 0x15, 0x9a, 0x33, 0xa9, 0x14, 0x69, 0xac,
        0xe7, 0xa2, 0x3d, 0xbf, 0xd0, 0x13, 0x8c, 0x75,
        0x12, 0x73, 0xc8, 0xe8, 0x9d, 0xe0, 0xda, 0x51,
        0xad, 0x88, 0x08, 0x33, 0xe3, 0x7a, 0x92, 0x5a,
        0x2c, 0x6a, 0x15, 0xef, 0xa9, 0xb1, 0x0d, 0xcf,
        0x1f, 0x03, 0x88, 0xfe, 0x0d, 0x92, 0xb1, 0x2c,
        0x16, 0x11, 0x12, 0xc9, 0xda, 0xe4, 0x61, 0x0f,
        0x87, 0x4d, 0x7b, 0x04, 0x4e, 0x31, 0x70, 0xd1,
        0x79, 0x63, 0x70, 0x23, 0x95, 0x13, 0x01, 0xc9,
        0xfa, 0x7c, 0x02, 0xb6, 0xd3, 0xaf, 0x59, 0xa2,
        0x3f, 0xe4, 0xaf, 0xbd, 0x46, 0x13, 0x2d, 0x12,
        0xdb, 0x47, 0x27, 0x1b, 0x9e, 0x2d, 0x50, 0x93,
        0x36, 0x5f, 0xba, 0xa1
    };
    char aes256_key[] = {
        0x11, 0xff, 0x9a, 0xc9, 0xd4, 0x71, 0xbd, 0x9a,
        0x2c, 0xd4, 0x58, 0x30, 0xdf, 0x18, 0x75, 0x77,
        0x62, 0xca, 0x70, 0x50, 0xe1, 0x0e, 0x8f, 0xdf,
        0x6f, 0xef, 0xb0, 0x60, 0x53, 0x6a, 0xfe, 0xd2
    };
    // ¼ÓÃÜ AES256 key
    LPBYTE OutData = NULL;
    DWORD OutData_Len = rsa_Encrypt(rsa_public_key, sizeof(rsa_public_key), (LPBYTE)aes256_key, sizeof(aes256_key), &OutData);
    printf("rsa encrypt data:\n");
    print_bin2c(OutData, OutData_Len);
    printf("\n\n");
    BYTE rsa_private_key[] = {
        0x07, 0x02, 0x00, 0x00, 0x00, 0xa4, 0x00, 0x00,
        0x52, 0x53, 0x41, 0x32, 0x00, 0x08, 0x00, 0x00,
        0x01, 0x00, 0x01, 0x00, 0x77, 0xe5, 0xeb, 0x1f,
        0xae, 0xd8, 0xad, 0xd4, 0xe9, 0x28, 0xbf, 0x53,
        0x38, 0xd4, 0xd3, 0xcf, 0xf2, 0xa0, 0x50, 0x41,
        0xd6, 0x03, 0xe2, 0x23, 0x2c, 0x82, 0x38, 0x1a,
        0x5d, 0x5d, 0x0d, 0x6f, 0xa4, 0xc7, 0x67, 0x7b,
        0x5e, 0xa3, 0x26, 0x6e, 0x78, 0x35, 0xef, 0xca,
        0x19, 0x1c, 0xb8, 0xac, 0x0b, 0xe4, 0x79, 0xc9,
        0x4d, 0x7b, 0xd2, 0xea, 0x99, 0xcc, 0x4b, 0x60,
        0xff, 0xfc, 0x2f, 0x9c, 0x07, 0xad, 0x27, 0x84,
        0x4c, 0x64, 0x0e, 0x86, 0x9a, 0x8f, 0xb3, 0x34,
        0x35, 0x64, 0x13, 0x55, 0x6a, 0x84, 0x44, 0xb2,
        0x6d, 0x62, 0x28, 0xd3, 0xfe, 0xc3, 0x0f, 0x67,
        0x09, 0x25, 0xb5, 0x2c, 0x66, 0x80, 0x07, 0x3b,
        0xb5, 0xda, 0x0f, 0x55, 0xda, 0xee, 0xa0, 0x4f,
        0x6d, 0x60, 0x02, 0xb1, 0x34, 0x0d, 0xbd, 0xeb,
        0x07, 0xcd, 0x86, 0x8c, 0x36, 0xca, 0x98, 0x21,
        0x9c, 0x68, 0x48, 0x60, 0xb5, 0xe2, 0x80, 0x9c,
        0xe8, 0xc1, 0xdd, 0xb0, 0x74, 0xd9, 0x1e, 0xea,
        0x3b, 0x52, 0x21, 0x6a, 0xb1, 0x5b, 0xbb, 0xf3,
        0xd5, 0x80, 0xce, 0x33, 0x6f, 0x3d, 0xe2, 0x36,
        0xd8, 0x15, 0x9a, 0x33, 0xa9, 0x14, 0x69, 0xac,
        0xe7, 0xa2, 0x3d, 0xbf, 0xd0, 0x13, 0x8c, 0x75,
        0x12, 0x73, 0xc8, 0xe8, 0x9d, 0xe0, 0xda, 0x51,
        0xad, 0x88, 0x08, 0x33, 0xe3, 0x7a, 0x92, 0x5a,
        0x2c, 0x6a, 0x15, 0xef, 0xa9, 0xb1, 0x0d, 0xcf,
        0x1f, 0x03, 0x88, 0xfe, 0x0d, 0x92, 0xb1, 0x2c,
        0x16, 0x11, 0x12, 0xc9, 0xda, 0xe4, 0x61, 0x0f,
        0x87, 0x4d, 0x7b, 0x04, 0x4e, 0x31, 0x70, 0xd1,
        0x79, 0x63, 0x70, 0x23, 0x95, 0x13, 0x01, 0xc9,
        0xfa, 0x7c, 0x02, 0xb6, 0xd3, 0xaf, 0x59, 0xa2,
        0x3f, 0xe4, 0xaf, 0xbd, 0x46, 0x13, 0x2d, 0x12,
        0xdb, 0x47, 0x27, 0x1b, 0x9e, 0x2d, 0x50, 0x93,
        0x36, 0x5f, 0xba, 0xa1, 0x49, 0x0f, 0x6f, 0xd4,
        0x58, 0x44, 0x1a, 0x4e, 0x34, 0x94, 0xaa, 0xe0,
        0x70, 0xcd, 0x93, 0xe7, 0x74, 0xf1, 0x11, 0xe7,
        0x55, 0xae, 0x37, 0xf4, 0x33, 0x6c, 0x6b, 0xe0,
        0x0e, 0x5a, 0xb1, 0x92, 0x8b, 0x4e, 0xe1, 0xc4,
        0xbf, 0x88, 0x97, 0xab, 0xce, 0xd9, 0x82, 0x12,
        0x71, 0x2b, 0xcc, 0x77, 0x17, 0x7c, 0x8c, 0x9e,
        0x1e, 0xad, 0xa8, 0x5c, 0x5c, 0x3a, 0x59, 0xdc,
        0xf2, 0xee, 0x49, 0xe6, 0x8f, 0xd0, 0xc1, 0x18,
        0xaf, 0x9d, 0xad, 0xf3, 0x0b, 0x7d, 0xe9, 0x01,
        0x94, 0x38, 0xa9, 0x1f, 0xfa, 0x24, 0xca, 0xc0,
        0xad, 0x7b, 0xab, 0xa5, 0xa2, 0xa7, 0xe3, 0xe3,
        0x96, 0x1e, 0x93, 0xb2, 0x17, 0xa8, 0xe2, 0xb0,
        0x67, 0x30, 0x3b, 0x6a, 0xef, 0x2d, 0xd0, 0x27,
        0x56, 0xf5, 0x61, 0x4c, 0x77, 0xf1, 0x94, 0x3e,
        0xa0, 0xbe, 0xd3, 0x77, 0xfa, 0xc4, 0x03, 0xef,
        0xb8, 0xbc, 0x99, 0xd5, 0xbf, 0x8e, 0xed, 0xe0,
        0x59, 0x0c, 0xea, 0x4d, 0x8e, 0xec, 0x4b, 0x18,
        0xf3, 0xbf, 0xa7, 0x13, 0xbd, 0x72, 0xba, 0x3d,
        0x97, 0x11, 0xfe, 0x11, 0xf8, 0xd3, 0xc9, 0xeb,
        0xa9, 0x9b, 0x13, 0x91, 0xbc, 0x6e, 0x89, 0x12,
        0x35, 0xf2, 0xd1, 0x76, 0x98, 0xba, 0xce, 0xc4,
        0xb0, 0xc3, 0x65, 0x88, 0xb8, 0x3b, 0x56, 0x57,
        0xb3, 0xa7, 0x0e, 0x37, 0x33, 0xb1, 0x55, 0x00,
        0xb5, 0xab, 0x03, 0x51, 0x9b, 0xbb, 0x6e, 0x80,
        0x4a, 0x22, 0x3e, 0xed, 0x40, 0x5c, 0x4f, 0x96,
        0x81, 0x9e, 0xb6, 0x92, 0xa8, 0x9d, 0xa0, 0x7a,
        0xd4, 0xd3, 0xa1, 0x15, 0xa4, 0xcf, 0x96, 0x4a,
        0x22, 0x7c, 0xae, 0xbd, 0x19, 0x5b, 0x0b, 0xea,
        0x18, 0x04, 0xf1, 0x52, 0xe1, 0xbd, 0x62, 0x6b,
        0x95, 0xed, 0xe5, 0x1f, 0x30, 0x59, 0x7b, 0x38,
        0x03, 0x5b, 0x96, 0x6b, 0x6c, 0xba, 0x84, 0x20,
        0x1f, 0xb2, 0xd4, 0xc1, 0x81, 0x61, 0x6e, 0xb2,
        0x6d, 0x1c, 0xa6, 0xbd, 0x9d, 0x68, 0x64, 0x07,
        0xde, 0xaa, 0xe5, 0x2e, 0xc0, 0x37, 0x2d, 0xd9,
        0x09, 0x24, 0x1a, 0xcf, 0xda, 0xc1, 0x5b, 0xb5,
        0x77, 0xb1, 0x91, 0xb9, 0xc4, 0xfc, 0x89, 0x2c,
        0x72, 0xc9, 0xc8, 0xb2, 0x84, 0x7b, 0x7d, 0xe9,
        0x95, 0x74, 0xf6, 0xc1, 0x3f, 0x0e, 0x6b, 0xdf,
        0xca, 0x52, 0xbf, 0xe9, 0x77, 0xdb, 0x8d, 0x8b,
        0x0e, 0xa7, 0xc6, 0xff, 0x20, 0x1d, 0x00, 0x55,
        0x2e, 0x1d, 0x23, 0x1b, 0x31, 0xaa, 0xa3, 0x5f,
        0x90, 0x36, 0x09, 0x37, 0x58, 0xd4, 0x4b, 0x17,
        0x58, 0xa9, 0x89, 0x6d, 0x1c, 0xf1, 0xb0, 0x16,
        0x75, 0x4e, 0xdb, 0xf1, 0x49, 0x2c, 0xef, 0x8e,
        0xcf, 0x05, 0x3a, 0xe2, 0x44, 0xcf, 0x9e, 0x5a,
        0xf1, 0x81, 0xe7, 0xf6, 0x03, 0x01, 0xfa, 0xed,
        0xdb, 0xae, 0x64, 0x53, 0xe3, 0xcc, 0xde, 0x67,
        0x4a, 0xaf, 0xa2, 0x32, 0x07, 0x18, 0x6e, 0xb8,
        0xe8, 0x8d, 0xc4, 0x0a, 0x6e, 0x23, 0xcf, 0x4f,
        0xec, 0x3e, 0x98, 0xa4, 0x22, 0x68, 0xd6, 0x67,
        0xd6, 0x28, 0x0e, 0x8e, 0x09, 0xf8, 0xbe, 0x95,
        0xea, 0xc2, 0x8d, 0xf0, 0xce, 0x2c, 0x15, 0x35,
        0x2f, 0xd9, 0x12, 0x5f, 0x67, 0x3e, 0xb9, 0x45,
        0x27, 0x13, 0xec, 0x79, 0xc9, 0xcc, 0xe0, 0xc6,
        0x29, 0xd4, 0x5c, 0x7f, 0xae, 0xb0, 0x1c, 0x45,
        0x75, 0x5b, 0x5b, 0x09, 0xfe, 0x22, 0x37, 0xfb,
        0x01, 0xc2, 0xe9, 0x8a, 0x7a, 0x38, 0xe1, 0x3f,
        0x7e, 0x94, 0x60, 0xfe, 0x43, 0xce, 0xcf, 0x42,
        0x0f, 0xa3, 0x0f, 0x62, 0xf4, 0x56, 0xb6, 0x06,
        0x1c, 0x6b, 0x61, 0x97, 0x68, 0x49, 0x28, 0x73,
        0xae, 0x8a, 0x3d, 0xf4, 0x5b, 0x16, 0xa3, 0x92,
        0x72, 0x31, 0xb5, 0xcc, 0xdd, 0x7f, 0x94, 0x61,
        0x5f, 0x38, 0x1b, 0x34, 0xc6, 0xcc, 0x4e, 0x39,
        0x2d, 0xd9, 0x1f, 0xb7, 0xe4, 0x37, 0xa9, 0x6a,
        0x07, 0xfd, 0x20, 0x3e, 0xf0, 0xaf, 0x28, 0x81,
        0xf0, 0xf5, 0x36, 0xa4, 0xa3, 0x84, 0x28, 0x25,
        0x0a, 0xe4, 0x5f, 0x8c, 0xc4, 0xe9, 0x1d, 0xff,
        0x50, 0x60, 0xaf, 0x4f, 0xaa, 0xa6, 0x77, 0x00,
        0x27, 0x90, 0x09, 0x6f, 0x2f, 0x44, 0xec, 0x57,
        0x69, 0xdc, 0x8a, 0xb7, 0x05, 0xda, 0xe1, 0xf9,
        0x08, 0x5f, 0x33, 0xcc, 0x77, 0xaf, 0xca, 0xc3,
        0x6c, 0x78, 0x1a, 0x00, 0x7f, 0x4d, 0x99, 0x44,
        0x32, 0x5d, 0xf6, 0x88, 0x12, 0x1f, 0x47, 0x0c,
        0x45, 0x17, 0x2d, 0xc0, 0x8f, 0x7d, 0xbf, 0x4b,
        0x31, 0x24, 0x5a, 0x0d, 0x40, 0xda, 0xb9, 0x22,
        0x61, 0x2d, 0x63, 0x9b, 0x18, 0x11, 0x51, 0x60,
        0x67, 0x7c, 0x63, 0x68, 0xc2, 0x11, 0x3a, 0x99,
        0x14, 0x00, 0xcd, 0x05, 0xcc, 0x23, 0x8f, 0x5b,
        0xcc, 0x98, 0xfb, 0x68, 0xed, 0x01, 0x72, 0xcd,
        0xb7, 0x46, 0xc3, 0x48, 0xa1, 0xa6, 0xc8, 0x83,
        0xca, 0x00, 0x69, 0x13, 0x68, 0x97, 0xd8, 0x94,
        0xe2, 0x54, 0x06, 0x62, 0x88, 0xb1, 0xef, 0xc7,
        0x10, 0xf8, 0x62, 0xc0, 0xf2, 0x8f, 0xe3, 0xfd,
        0xd9, 0x0c, 0xfa, 0x68, 0xad, 0x0e, 0xa4, 0xda,
        0x26, 0x84, 0x0e, 0x00, 0xc8, 0xac, 0x4d, 0x2c,
        0xb3, 0x94, 0x42, 0x8d, 0x73, 0xb2, 0x2c, 0x75,
        0xbe, 0xc5, 0xa2, 0xdb, 0x12, 0x4d, 0xf5, 0xcf,
        0xee, 0x04, 0x7b, 0xe5, 0xe9, 0x0c, 0x4d, 0x49,
        0xb2, 0x2b, 0xdb, 0xa1, 0xf2, 0x39, 0x4b, 0xdb,
        0xea, 0xf0, 0x04, 0xd6, 0x09, 0x3a, 0xbb, 0x99,
        0x43, 0xf8, 0xc1, 0x32, 0x0a, 0xfa, 0x88, 0x25,
        0x9b, 0x8e, 0x6b, 0x3a, 0xd4, 0x47, 0x6c, 0x31,
        0xaf, 0xa2, 0x0a, 0xc9, 0xbb, 0xcf, 0x89, 0x2a,
        0x63, 0x97, 0x0e, 0xbf, 0x29, 0x30, 0xca, 0x44,
        0x19, 0xba, 0x43, 0xcd, 0xea, 0x04, 0x63, 0x88,
        0x58, 0x52, 0x9a, 0x35, 0x0f, 0x1a, 0x0f, 0xe2,
        0x3d, 0xff, 0x23, 0x86, 0xea, 0xfb, 0xcd, 0xc1,
        0xe7, 0xaa, 0x41, 0x6f, 0xc5, 0xbd, 0x21, 0x73,
        0x57, 0xce, 0x8e, 0xae, 0x3c, 0xde, 0xc8, 0xb2,
        0x4b, 0x41, 0x41, 0x93, 0x9e, 0x1c, 0x3c, 0xc5,
        0xfd, 0x9e, 0x1c, 0x7c, 0xb3, 0x94, 0xf9, 0x7f,
        0x5e, 0x04, 0x21, 0xb4, 0x6e, 0x9d, 0x3d, 0xa2,
        0xa5, 0xdf, 0x81, 0xb1, 0x64, 0x1b, 0xbb, 0x26,
        0x08, 0x90, 0xd8, 0xca, 0x6a, 0x8e, 0xb7, 0xeb,
        0xe1, 0xeb, 0xc2, 0x26, 0x9a, 0x10, 0x42, 0x68,
        0x09, 0x9b, 0xa1, 0x1e, 0x9a, 0xaf, 0x7a, 0x97,
        0x8e, 0xd1, 0xc6, 0xc9, 0xf4, 0x21, 0xdf, 0x87,
        0xef, 0xb5, 0x38, 0xa7, 0x52, 0xb4, 0xef, 0x89,
        0x09, 0x81, 0x04, 0x60, 0xa4, 0x47, 0x81, 0x5e,
        0x50, 0xc5, 0xc1, 0x3a, 0xd8, 0xac, 0xe6, 0x14,
        0x03, 0x36, 0x06, 0x49, 0xe5, 0xbd, 0xa4, 0x8a,
        0x64, 0x48, 0xa0, 0x17
    };
    DWORD Decrypt_Len = rsa_Decrypt(rsa_private_key, sizeof(rsa_private_key), OutData, &OutData_Len);
    printf("rsa decrypt data:\n");
    print_bin2c(OutData, Decrypt_Len);
    printf("\n\n");
}

void gen_rsa_keys(DWORD keylen)
{
    BOOL bStatus = FALSE;
    HCRYPTPROV hProv = 0;    // crypto API provider
    HCRYPTKEY  hKey = 0;    // key object
    BYTE* pbBlob = NULL;
    DWORD dwBlob = 0;
    BYTE* pbBlob2 = NULL;
    DWORD dwBlob2 = 0;
    char* cipherText = NULL;
    unsigned long cLen;
    char* cipherText2 = NULL;
    unsigned long cLen2;
    char* cipherText3 = NULL;
    unsigned long cLen3;
    char* cipherText4 = NULL;
    unsigned long cLen4;

    do {
        if (!OpenCryptContext(&hProv)) {
            xstrerror("CryptAcquireContext()");
            break;
        }

        //if (!CryptGenKey(hProv, AT_SIGNATURE, keylen << 16 | CRYPT_EXPORTABLE, &hKey)) {
        //  xstrerror("CryptGenKey()");
        //  break;
        //}

        if (!CryptGenKey(hProv, AT_KEYEXCHANGE, RSA2048BIT_KEY | CRYPT_EXPORTABLE, &hKey)) {
            xstrerror("CryptGenKey()");
            break;
        }

        if (!CryptExportKey(hKey, 0, PUBLICKEYBLOB, 0, NULL, &dwBlob)) {
            xstrerror("CryptGenKey()");
            break;
        }

        pbBlob = (PBYTE)xmalloc(dwBlob);

        if (!pbBlob) {
            xstrerror("xmalloc()");
            break;
        }

        // get blob
        if (!CryptExportKey(hKey, 0, PUBLICKEYBLOB, 0, pbBlob, &dwBlob)) {
            xstrerror("CryptExportKey()");
            break;
        }

        printf("rsa public key:\n");
        print_bin2c(pbBlob, dwBlob);
        printf("\n\n");
        printf("rsa public key len: %d\n", dwBlob);
        printf("\n\n");

        if (!Base64EncodeA(&cipherText, &cLen, pbBlob, dwBlob)) {
            xstrerror("Base64EncodeA()");
            break;
        }

        printf("rsa base64 public key:\n");
        printf(cipherText);
        printf("\n\n");

        // Hex ±àÂë
        if (!Bin2Hex(&cipherText2, &cLen2, pbBlob, dwBlob)) {
            xstrerror("Bin2Hex()");
            break;
        }

        printf("rsa hex public key:\n");
        printf(cipherText2);
        printf("\n\n");

        // µ¼³öË½Ô¿
        if (!CryptExportKey(hKey, 0, PRIVATEKEYBLOB, 0, NULL, &dwBlob2)) {
            xstrerror("CryptGenKey()");
            break;
        }

        pbBlob2 = (PBYTE)xmalloc(dwBlob2);

        if (!pbBlob2) {
            xstrerror("xmalloc()");
            break;
        }

        // get blob
        if (!CryptExportKey(hKey, 0, PRIVATEKEYBLOB, 0, pbBlob2, &dwBlob2)) {
            xstrerror("CryptExportKey()");
            break;
        }

        printf("rsa private key:\n");
        print_bin2c(pbBlob2, dwBlob2);
        printf("\n\n");
        printf("rsa private key len: %d\n", dwBlob2);
        printf("\n\n");

        if (!Base64EncodeA(&cipherText3, &cLen3, pbBlob2, dwBlob2)) {
            xstrerror("Base64EncodeA()");
            break;
        }

        printf("rsa base64 private key:\n");
        printf(cipherText3);
        printf("\n\n");

        // Hex ±àÂë
        if (!Bin2Hex(&cipherText4, &cLen4, pbBlob2, dwBlob2)) {
            xstrerror("Bin2Hex()");
            break;
        }

        printf("rsa hex private key:\n");
        printf(cipherText4);
        printf("\n\n");
    } while (0);

    if (cipherText) {
        xfree(cipherText);
        cipherText = NULL;
    }

    if (cipherText2) {
        xfree(cipherText2);
        cipherText2 = NULL;
    }

    if (cipherText3) {
        xfree(cipherText3);
        cipherText3 = NULL;
    }

    if (cipherText4) {
        xfree(cipherText4);
        cipherText4 = NULL;
    }

    if (pbBlob2) {
        xfree(pbBlob2);
        pbBlob2 = NULL;
    }

    if (pbBlob) {
        xfree(pbBlob);
        pbBlob = NULL;
    }

    if (hKey) {
        CryptDestroyKey(hKey);
    }

    // release provider
    if (hProv != 0) {
        CryptReleaseContext(hProv, 0);
        hProv = 0;
    }
}

BOOL sign_file2(std::string filename)
{
    BOOL bStatus = FALSE;
    HCRYPTPROV hProv = 0;    // crypto API provider
    HCRYPTKEY  hKey = 0;    // key object
    char* p;
    HCRYPTHASH hHash = 0;    // hash object
    DWORD dwSigLen = 0;
    BYTE* pbSignature = NULL;

    do {
        if (!OpenCryptContext(&hProv)) {
            xstrerror("CryptAcquireContext()");
            break;
        }

        std::vector<BYTE> rsa_private_key;

        if (!get_file_contents("rsa_private.bin", rsa_private_key)) {
            xstrerror("get_file_contents()");
            break;
        }

        bStatus = CryptImportKey(hProv, &rsa_private_key[0], rsa_private_key.size(), 0, 0, &hKey);

        if (!bStatus) {
            xstrerror("CryptImportKey()");
            break;
        }

        std::vector<BYTE> inData;

        if (!get_file_contents(filename.c_str(), inData)) {
            xstrerror("get_file_contents()");
            break;
        }

        // create hash object
        if (!CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &hHash)) {
            xstrerror("CryptCreateHash()");
            break;
        }

        // hash input
        if (!CryptHashData(hHash, &inData[0], inData.size(), 0)) {
            xstrerror("CryptHashData()");
            break;
        }

        // obtain size of signature
        if (!CryptSignHash(hHash, AT_SIGNATURE, NULL, 0, NULL, &dwSigLen)) {
            xstrerror("CryptSignHash()");
            break;
        }

        pbSignature = (BYTE*)xmalloc(dwSigLen);

        // sign the hash to obtain signature
        if (!CryptSignHash(hHash, AT_SIGNATURE, NULL, 0, pbSignature, &dwSigLen)) {
            xstrerror("CryptSignHash()");
            break;
        }

        p = (char*)sig2hex(pbSignature, dwSigLen);

        if (p) {
            printf("  [ signature is: %i::%s\n", lstrlen(p), p);
            put_file_content((filename).c_str(), &inData[0], inData.size());
            put_file_sign_content((filename).c_str(), pbSignature, dwSigLen);
        }

        bStatus = TRUE;
    } while (0);

Exit0:

    if (pbSignature) {
        xfree(pbSignature);
        pbSignature = NULL;
    }

    if (hHash != 0) {
        CryptDestroyHash(hHash);
        hHash = 0;
    }

    if (hKey) {
        CryptDestroyKey(hKey);
    }

    // release provider
    if (hProv != 0) {
        CryptReleaseContext(hProv, 0);
        hProv = 0;
    }

    return bStatus;
}

BOOL verify_file2(std::string filename)
{
    BOOL bStatus = FALSE;
    HCRYPTPROV hProv = 0;    // crypto API provider
    HCRYPTKEY  hKey = 0;    // key object
    HCRYPTHASH hHash = 0;    // hash object
    std::vector<BYTE> sign_message;

    do {
        if (!OpenCryptContext(&hProv)) {
            xstrerror("CryptAcquireContext()");
            break;
        }

        std::vector<BYTE> rsa_public_key;

        if (!get_file_contents("rsa_public.bin", rsa_public_key)) {
            xstrerror("get_file_contents()");
            break;
        }

        bStatus = CryptImportKey(hProv, &rsa_public_key[0], rsa_public_key.size(), 0, 0, &hKey);

        if (!bStatus) {
            xstrerror("CryptImportKey()");
            break;
        }

        std::vector<BYTE> enc_file_data;

        if (!get_enc_file_data(filename.c_str(), enc_file_data)) {
            xstrerror("get_enc_file_data()");
            break;
        }

        // create hash object
        if (!CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &hHash)) {
            xstrerror("CryptCreateHash()");
            break;
        }

        if (!CryptHashData(hHash, &enc_file_data[0], enc_file_data.size(), 0)) {
            xstrerror("CryptHashData()");
            break;
        }

        if (!get_enc_file_sign_message(filename.c_str(), sign_message)) {
            xstrerror("get_enc_file_sign_message()");
            break;
        }

        if (sign_message.size() > 0) {
            // verify signature
            bStatus = CryptVerifySignature(hHash, &sign_message[0],
                                           sign_message.size(), hKey, NULL, 0);
            printf("  [ signature is %s\n", bStatus ? "valid" : "invalid");
        }
    } while (0);

    if (hHash != 0) {
        CryptDestroyHash(hHash);
        hHash = 0;
    }

    if (hKey) {
        CryptDestroyKey(hKey);
    }

    // release provider
    if (hProv != 0) {
        CryptReleaseContext(hProv, 0);
        hProv = 0;
    }

    return bStatus;
}

//
//static bool generateKeys(HCRYPTKEY *key, HCRYPTPROV provider, unsigned char **publicKey, unsigned char **privateKey)
//{
//  unsigned long publicKeyLen = 0;
//  unsigned long privateKeyLen = 0;
//
//  if (!provider)
//      return false;
//
//  if (!CryptGenKey(provider, AT_KEYEXCHANGE, RSA2048BIT_KEY | CRYPT_EXPORTABLE, key))
//  {
//      return false;
//  }
//
//  if (!CryptExportKey(*key, 0, PUBLICKEYBLOB, 0, NULL, &publicKeyLen))
//  {
//      if (*key) CryptDestroyKey(*key);
//      return false;
//  }
//
//  *publicKey = (unsigned char *)malloc(publicKeyLen * sizeof(unsigned char));
//  if (*publicKey == NULL)
//  {
//      if (*key) CryptDestroyKey(*key);
//      return false;
//  }
//  SecureZeroMemory(*publicKey, publicKeyLen * sizeof(unsigned char));
//
//  if (!CryptExportKey(*key, 0, PUBLICKEYBLOB, 0, *publicKey, &publicKeyLen))
//  {
//      SAFE_FREE(*publicKey);
//      if (*key) CryptDestroyKey(*key);
//      return false;
//  }
//
//  if (!CryptExportKey(*key, 0, PRIVATEKEYBLOB, 0, NULL, &privateKeyLen))
//  {
//      SAFE_FREE(*publicKey);
//      if (*key) CryptDestroyKey(*key);
//      return false;
//  }
//
//  *privateKey = (unsigned char *)malloc(privateKeyLen * sizeof(unsigned char));
//  if (*privateKey == NULL)
//  {
//      SAFE_FREE(*publicKey);
//      if (*key) CryptDestroyKey(*key);
//      return false;
//  }
//  SecureZeroMemory(*privateKey, privateKeyLen * sizeof(unsigned char));
//
//  if (!CryptExportKey(*key, 0, PRIVATEKEYBLOB, 0, *privateKey, &privateKeyLen))
//  {
//      SAFE_FREE(*publicKey);
//      SAFE_FREE(*privateKey);
//      if (*key) CryptDestroyKey(*key);
//      return false;
//  }
//
//  return true;
//}



//bool CryptoInit(HCRYPTKEY *key, HCRYPTPROV *provider, unsigned char **publicKey, unsigned char **privateKey)
//{
//  if (!CryptAcquireContextW(provider, NULL, NULL, PROV_RSA_FULL, 0))
//  {
//      if (GetLastError() == NTE_BAD_KEYSET)
//      {
//          if (!CryptAcquireContextW(provider, NULL, NULL, PROV_RSA_FULL, CRYPT_NEWKEYSET))
//          {
//              return false;
//          }
//      }
//      else
//      {
//          return false;
//      }
//  }
//
//  if (!generateKeys(key, *provider, publicKey, privateKey))
//  {
//      if (*provider) CryptReleaseContext(*provider, 0);
//      return false;
//  }
//
//  return true;
//}
//
//bool Encrypt(HCRYPTKEY key, char **cipherText, unsigned long *cLen, unsigned char *plainText, unsigned long pLen)
//{
//  unsigned long len = 0;
//  unsigned char *encrypted = 0;
//  unsigned long enLen = 0;
//
//  len = pLen + 1;
//
//  if (!CryptEncrypt(key, 0, TRUE, 0, NULL, &len, 0))
//  {
//      if (key) CryptDestroyKey(key);
//      return false;
//  }
//
//  enLen = len;
//
//  encrypted = (unsigned char *)malloc(len * sizeof(unsigned char));
//  if (encrypted == NULL)
//  {
//      if (key) CryptDestroyKey(key);
//      return false;
//  }
//  SecureZeroMemory(encrypted, len * sizeof(unsigned char));
//
//  memcpy_s(encrypted, len, plainText, pLen + 1);
//
//  len = pLen + 1;
//  if (!CryptEncrypt(key, 0, TRUE, 0, encrypted, &len, enLen))
//  {
//      SAFE_FREE(encrypted);
//      if (key) CryptDestroyKey(key);
//      return false;
//  }
//
//  if (!Base64EncodeA(cipherText, cLen, encrypted, enLen))
//  {
//      SAFE_FREE(encrypted);
//      if (key) CryptDestroyKey(key);
//      return false;
//  }
//
//  SAFE_FREE(encrypted);
//
//  return true;
//}
//
//bool Decrypt(HCRYPTKEY key, unsigned char **plainText, char *cipherText, unsigned long cLen)
//{
//  unsigned long len = 0;
//  unsigned long decodedLen = 0;
//  char *decoded = 0;
//
//  if (!Base64DecodeA(&decoded, &decodedLen, cipherText, cLen))
//  {
//      if (key) CryptDestroyKey(key);
//      return false;
//  }
//
//  *plainText = (unsigned char *)malloc(decodedLen * sizeof(unsigned char));
//  if (*plainText == NULL)
//  {
//      if (key) CryptDestroyKey(key);
//      return false;
//  }
//  SecureZeroMemory(*plainText, decodedLen * sizeof(unsigned char));
//
//  memcpy_s(*plainText, decodedLen, decoded, decodedLen);
//
//  SAFE_FREE(decoded);
//
//  len = decodedLen;
//  if (!CryptDecrypt(key, 0, TRUE, 0, *plainText, &len))
//  {
//      SAFE_FREE(*plainText);
//      if (key) CryptDestroyKey(key);
//      return false;
//  }
//
//  return true;
//}

//void CryptoUninit(HCRYPTKEY key, HCRYPTPROV provider)
//{
//  if (key)
//      if (!CryptDestroyKey(key))
//          printf("Error: %d\n", GetLastError());
//
//  if (provider)
//      if (!CryptReleaseContext(provider, 0))
//          printf("Error: %d\n", GetLastError());
//
//  if (!CryptAcquireContextW(&provider, NULL, NULL, PROV_RSA_FULL, CRYPT_DELETEKEYSET))
//      printf("Error: %d\n", GetLastError());
//}